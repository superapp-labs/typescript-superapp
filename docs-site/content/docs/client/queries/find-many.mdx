---
title: Select Queries
description: Fetch rows with filtering, sorting, joins, pagination, and relational queries.
icon: Search
---

Drizzle provides two query styles: the **select builder** for SQL-like queries, and **relational queries** for loading nested data.

## Select Builder

```typescript
import { drizzle } from '@superapp/db'
import { eq, desc } from 'drizzle-orm'
import * as schema from './generated/schema'

const db = drizzle({ connection, token, schema })

const orders = await db.select()
  .from(schema.orders)
  .where(eq(schema.orders.status, 'active'))
  .orderBy(desc(schema.orders.createdAt))
  .limit(10)
```

## Select Specific Columns

```typescript
const orders = await db.select({
  id: schema.orders.id,
  amount: schema.orders.amount,
  status: schema.orders.status,
}).from(schema.orders)
```

## Filtering

```typescript
import { eq, gte, and } from 'drizzle-orm'

const activeHighValue = await db.select()
  .from(schema.orders)
  .where(and(
    eq(schema.orders.status, 'active'),
    gte(schema.orders.amount, 100)
  ))
```

## Sorting and Pagination

```typescript
import { desc } from 'drizzle-orm'

const page2 = await db.select()
  .from(schema.orders)
  .orderBy(desc(schema.orders.createdAt))
  .limit(20)
  .offset(20)
```

## Joins

```typescript
const ordersWithCustomer = await db.select({
  orderId: schema.orders.id,
  amount: schema.orders.amount,
  customerName: schema.customers.name,
}).from(schema.orders)
  .leftJoin(schema.customers, eq(schema.orders.customerId, schema.customers.id))
```

## Relational Queries

Use `db.query` for loading nested relations â€” similar to Prisma's `include`.

```typescript
const ordersWithCustomer = await db.query.orders.findMany({
  with: { customer: true },
  where: eq(schema.orders.status, 'active'),
  orderBy: desc(schema.orders.createdAt),
  limit: 10,
})
// { id, amount, status, customer: { id, name, email } }[]
```

## Complex Filters

```typescript
import { eq, gte, lt, or, and } from 'drizzle-orm'

const filtered = await db.select()
  .from(schema.orders)
  .where(or(
    and(eq(schema.orders.status, 'active'), gte(schema.orders.amount, 500)),
    and(eq(schema.orders.status, 'pending'), lt(schema.orders.amount, 100))
  ))
```
