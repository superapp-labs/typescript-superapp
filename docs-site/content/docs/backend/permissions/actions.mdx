---
title: Actions
icon: Zap
description: Define named server-side functions that clients can call by name, with full access to the database and user session.
---

Actions are named server-side functions defined on a permission. Instead of the client writing raw SQL for operations like incrementing stock or transferring balances, it calls an action by name — and the server runs your TypeScript with full Drizzle access.

```typescript
// Server — define the action on a permission
manage_products: {
  name: 'Manage products',
  table: 'main.products',
  operations: { select: true, update: true },
  filter: { organization_id: { $eq: '$user.current_org_id' } },
  actions: {
    incrementStock: async ({ user, db }, { productId, amount }) => {
      await db
        .update(products)
        .set({ stock: sql`stock + ${amount}` })
        .where(
          and(
            eq(products.id, productId),
            eq(products.organizationId, user.current_org_id),
          ),
        )
    },
  },
}
```

```typescript
// Client — call the action by name
const result = await superapp.action('incrementStock', {
  productId: 'prod_123',
  amount: 5,
})
```

## How It Works

1. Client sends `POST /actions/{actionName}` with a JSON body
2. Engine authenticates the user and resolves the session (same as any request)
3. Engine finds the permission that defines this action
4. Engine verifies the user's role grants that permission
5. Engine calls the action function with `({ user, db }, input)`
6. Action runs your TypeScript — any Drizzle queries, transactions, logic
7. Return value is sent back to the client as JSON

```text
  POST /actions/incrementStock + Bearer JWT + { productId, amount }
    │
    ▼
  1. Auth — JWT verification, session resolution
    │
    ▼
  2. Permission lookup — find which permission defines this action
    │
    ▼
  3. Role check — does the user's role include this permission?
    │
    ▼
  4. Execute action — your function runs with { user, db } and client input
    │
    ▼
  5. Response — return value sent as JSON
```

## Signature

Each action receives two arguments — the server context and the client input:

```typescript
actions: {
  actionName: async ({ user, db }, input) => {
    // user — resolved session (same as $user.* in filters)
    // db   — Drizzle query builder
    // input — whatever the client sent in the request body
    return result // sent back to client as JSON
  },
}
```

| Parameter | Type | Description |
|---|---|---|
| `user` | `UserSession` | Resolved session (same as `$user.*` in filters) |
| `db` | `DrizzleInstance` | Drizzle query builder — run any query |
| `input` | `any` | The client's request body (parsed JSON) |

The action can return any JSON-serializable value. If it returns nothing, the client receives `{ ok: true }`.

## Client API

```typescript
// Call an action
const result = await superapp.action('actionName', { ...params })

// The request is:
// POST /actions/actionName
// Authorization: Bearer <jwt>
// Body: { ...params }
```

## Examples

### Inventory: Increment and Decrement Stock

A warehouse management system where operators scan items in and out. The client shouldn't write raw `SET stock = stock + 1` SQL — the server controls the atomic update and validates bounds.

```typescript
manage_inventory: {
  name: 'Manage inventory',
  table: 'main.products',
  operations: { select: true },
  filter: { warehouse_id: { $eq: '$user.warehouse_id' } },
  actions: {
    incrementStock: async ({ user, db }, { productId, amount }) => {
      const [updated] = await db
        .update(products)
        .set({ stock: sql`stock + ${amount}` })
        .where(
          and(
            eq(products.id, productId),
            eq(products.warehouseId, user.warehouse_id),
          ),
        )
        .returning({ id: products.id, stock: products.stock })

      return updated
    },

    decrementStock: async ({ user, db }, { productId, amount }) => {
      // Check stock before decrementing
      const product = await db.query.products.findFirst({
        where: and(
          eq(products.id, productId),
          eq(products.warehouseId, user.warehouse_id),
        ),
      })
      if (!product) throw new PermissionError('Product not found')
      if (product.stock < amount) {
        throw new PermissionError(`Only ${product.stock} units available`)
      }

      const [updated] = await db
        .update(products)
        .set({ stock: sql`stock - ${amount}` })
        .where(eq(products.id, productId))
        .returning({ id: products.id, stock: products.stock })

      return updated
    },

    resetStock: async ({ user, db }, { productId }) => {
      await db
        .update(products)
        .set({ stock: 0, lastResetBy: user.id, lastResetAt: new Date() })
        .where(
          and(
            eq(products.id, productId),
            eq(products.warehouseId, user.warehouse_id),
          ),
        )
    },
  },
}
```

```typescript
// Client
await superapp.action('incrementStock', { productId: 'prod_123', amount: 10 })
await superapp.action('decrementStock', { productId: 'prod_123', amount: 3 })
await superapp.action('resetStock', { productId: 'prod_123' })
```

### Finance: Transfer Balance Between Accounts

A fintech app where users can transfer money between their accounts. The transfer must be atomic — debit and credit must both succeed or both fail. The client just says "transfer X from A to B" and the server handles the transaction.

```typescript
manage_accounts: {
  name: 'Manage accounts',
  table: 'main.accounts',
  operations: { select: true },
  filter: { owner_id: { $eq: '$user.id' } },
  actions: {
    transfer: async ({ user, db }, { fromAccountId, toAccountId, amount }) => {
      if (amount <= 0) throw new PermissionError('Amount must be positive')

      return db.transaction(async (tx) => {
        // Lock and validate source account
        const [source] = await tx
          .select()
          .from(accounts)
          .where(
            and(
              eq(accounts.id, fromAccountId),
              eq(accounts.ownerId, user.id),
            ),
          )
          .for('update')

        if (!source) throw new PermissionError('Source account not found')
        if (source.balance < amount) throw new PermissionError('Insufficient funds')

        // Validate destination (can be another user's account)
        const [dest] = await tx
          .select()
          .from(accounts)
          .where(eq(accounts.id, toAccountId))
          .for('update')

        if (!dest) throw new PermissionError('Destination account not found')

        // Atomic debit + credit
        await tx
          .update(accounts)
          .set({ balance: sql`balance - ${amount}` })
          .where(eq(accounts.id, fromAccountId))

        await tx
          .update(accounts)
          .set({ balance: sql`balance + ${amount}` })
          .where(eq(accounts.id, toAccountId))

        // Record the transaction
        await tx.insert(transactions).values({
          fromAccountId,
          toAccountId,
          amount,
          initiatedBy: user.id,
          timestamp: new Date(),
        })

        return { fromAccountId, toAccountId, amount }
      })
    },
  },
}
```

```typescript
// Client
await superapp.action('transfer', {
  fromAccountId: 'acc_checking',
  toAccountId: 'acc_savings',
  amount: 500,
})
```

### E-Commerce: Apply Discount Code

An online store where the client sends a discount code and the server validates it, calculates the discount, and applies it to the order. The discount logic (percentage vs fixed, expiration, usage limits) lives entirely on the server.

```typescript
manage_orders: {
  name: 'Manage orders',
  table: 'main.orders',
  operations: { select: true, update: true },
  filter: { customer_id: { $eq: '$user.id' } },
  actions: {
    applyDiscount: async ({ user, db }, { orderId, code }) => {
      return db.transaction(async (tx) => {
        const order = await tx.query.orders.findFirst({
          where: and(
            eq(orders.id, orderId),
            eq(orders.customerId, user.id),
            eq(orders.status, 'draft'),
          ),
        })
        if (!order) throw new PermissionError('Order not found or not editable')

        const discount = await tx.query.discountCodes.findFirst({
          where: and(
            eq(discountCodes.code, code.toUpperCase()),
            gt(discountCodes.expiresAt, new Date()),
            lt(discountCodes.usageCount, discountCodes.usageLimit),
          ),
        })
        if (!discount) throw new PermissionError('Invalid or expired discount code')

        const discountAmount = discount.type === 'percentage'
          ? order.subtotal * (discount.value / 100)
          : discount.value

        await tx
          .update(orders)
          .set({
            discountCode: code.toUpperCase(),
            discountAmount: Math.min(discountAmount, order.subtotal),
            total: order.subtotal - Math.min(discountAmount, order.subtotal),
          })
          .where(eq(orders.id, orderId))

        await tx
          .update(discountCodes)
          .set({ usageCount: sql`usage_count + 1` })
          .where(eq(discountCodes.id, discount.id))

        return {
          discountAmount: Math.min(discountAmount, order.subtotal),
          newTotal: order.subtotal - Math.min(discountAmount, order.subtotal),
        }
      })
    },
  },
}
```

```typescript
// Client
const { discountAmount, newTotal } = await superapp.action('applyDiscount', {
  orderId: 'ord_456',
  code: 'SUMMER20',
})
```

### Team Management: Invite Member with Role

A multi-tenant app where admins can invite new members to their organization. The action validates the email isn't already a member, creates the membership record, and sends an invite email — all in one call.

```typescript
manage_members: {
  name: 'Manage members',
  table: 'main.members',
  operations: { select: true, insert: true, delete: true },
  filter: { organization_id: { $eq: '$user.current_org_id' } },
  actions: {
    invite: async ({ user, db }, { email, role }) => {
      if (!['viewer', 'editor', 'admin'].includes(role)) {
        throw new PermissionError('Invalid role')
      }

      // Only admins can invite other admins
      if (role === 'admin' && !user.roles.includes('admin')) {
        throw new PermissionError('Only admins can invite admins')
      }

      // Check if already a member
      const existing = await db.query.members.findFirst({
        where: and(
          eq(members.organizationId, user.current_org_id),
          eq(members.email, email.toLowerCase()),
        ),
      })
      if (existing) throw new PermissionError('User is already a member')

      const [member] = await db
        .insert(members)
        .values({
          organizationId: user.current_org_id,
          email: email.toLowerCase(),
          role,
          status: 'invited',
          invitedBy: user.id,
          invitedAt: new Date(),
        })
        .returning()

      // Queue invite email
      await db.insert(emailJobs).values({
        to: email.toLowerCase(),
        template: 'org-invite',
        data: {
          inviterName: user.name,
          organizationName: user.org_name,
          role,
          inviteToken: member.id,
        },
      })

      return { memberId: member.id, status: 'invited' }
    },
  },
}
```

```typescript
// Client
await superapp.action('invite', {
  email: 'alice@example.com',
  role: 'editor',
})
```

### Analytics: Aggregate Report Generation

A dashboard where the client requests a pre-built report. The aggregation query is complex (multiple joins, window functions) and shouldn't be expressed as client-side SQL. The action runs a server-defined query and returns the computed result.

```typescript
view_analytics: {
  name: 'View analytics',
  table: 'main.orders',
  operations: { select: true },
  filter: { organization_id: { $eq: '$user.current_org_id' } },
  actions: {
    revenueReport: async ({ user, db }, { startDate, endDate }) => {
      const start = new Date(startDate)
      const end = new Date(endDate)

      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        throw new PermissionError('Invalid date range')
      }

      const report = await db
        .select({
          month: sql`DATE_TRUNC('month', ${orders.createdAt})`.as('month'),
          totalRevenue: sql`SUM(${orders.total})`.as('total_revenue'),
          orderCount: count(),
          avgOrderValue: sql`AVG(${orders.total})`.as('avg_order_value'),
        })
        .from(orders)
        .where(
          and(
            eq(orders.organizationId, user.current_org_id),
            gte(orders.createdAt, start),
            lte(orders.createdAt, end),
            eq(orders.status, 'completed'),
          ),
        )
        .groupBy(sql`DATE_TRUNC('month', ${orders.createdAt})`)
        .orderBy(sql`month`)

      return report
    },
  },
}
```

```typescript
// Client
const report = await superapp.action('revenueReport', {
  startDate: '2025-01-01',
  endDate: '2025-12-31',
})
```

## Actions vs CRUD vs Middleware

| | CRUD Operations | Middleware | Actions |
|---|---|---|---|
| **Client sends** | SQL via Drizzle Proxy | SQL via Drizzle Proxy | Action name + JSON params |
| **Server does** | Parse SQL, apply permissions, execute | Wrap the CRUD execution with custom logic | Run your function from scratch |
| **Use when** | Standard reads and writes | You need to intercept or extend a CRUD query | The operation doesn't map to a single SQL statement |

**Use CRUD** for straightforward reads and writes that declarative permissions can handle.

**Use middleware** when you need to intercept a CRUD query — add dynamic filters, validate business rules, transform results.

**Use actions** when the operation is a self-contained business function — transfers, multi-step workflows, aggregations, anything that doesn't map cleanly to a single `SELECT`/`INSERT`/`UPDATE`/`DELETE`.

## Security

Actions inherit the permission's role-based access control. If a user's role doesn't include the permission that defines the action, the request is rejected with `403 Forbidden` before your function runs.

However, actions do **not** automatically apply the permission's `filter`, `check`, or `preset` — those are CRUD-specific. You are responsible for scoping queries to the user's data inside the action function. Use `user.current_org_id`, `user.id`, and other session properties to enforce access control in your queries.

<Callout type="warn">
Always scope your queries inside actions. The permission's `filter` is not auto-applied — you must add your own `WHERE` conditions using session variables like `user.current_org_id`.
</Callout>

## When to Use

| Use Case | Recommendation |
|---|---|
| Read rows from a table | Use CRUD with [filters](/docs/backend/permissions/filters) |
| Insert/update/delete rows | Use CRUD with [checks](/docs/backend/permissions/checks) and [presets](/docs/backend/permissions/presets) |
| Intercept a CRUD query | Use [middleware](/docs/backend/permissions/middleware) |
| Atomic multi-table writes | Use `actions` with `db.transaction()` |
| Counter increments/decrements | Use `actions` |
| Balance transfers | Use `actions` with `db.transaction()` |
| Complex aggregation queries | Use `actions` |
| Multi-step business workflows | Use `actions` |
