---
title: Custom Hooks
icon: Code
description: Run custom TypeScript logic before or after query execution, with full access to the database and user session.
---

When declarative filters, checks, and presets are not enough, custom hooks let you run arbitrary TypeScript. This is the most powerful escape hatch — you get full access to the database, the user session, and the query context.

```typescript
permissions: {
  view_orders: {
    name: 'View orders',
    table: 'main.orders',
    operations: { select: true },
    columns: '*',
    hooks: {
      beforeExecute: async ({ user, db }) => {
        const subscription = await db.query.subscriptions.findFirst({
          where: eq(subscriptions.userId, user.id),
        })
        if (subscription?.status !== 'active') {
          throw new PermissionError('Active subscription required')
        }
      },
    },
  },
}
```

## Hook Types

A permission can define two hooks:

```typescript
hooks: {
  beforeExecute?: (ctx: HookContext) => Promise<HookResult | void>
  afterExecute?: (ctx: AfterHookContext) => Promise<any[] | void>
}
```

Both are optional. They run within the [request pipeline](/docs/advanced/request-pipeline) — `beforeExecute` runs after permission checks (step 6) but before DuckDB execution (step 7), and `afterExecute` runs after execution but before the response (step 9).

```text
  6. Permission Check — filters, checks, presets applied
    │
    ▼
  6a. beforeExecute hook ← runs here
    │
    ▼
  7. DuckDB Execution
    │
    ▼
  7a. afterExecute hook ← runs here
    │
    ▼
  8. Audit Log
```

## Hook Context

Both hooks receive a context object with everything you need:

```typescript
interface HookContext {
  /** Resolved user session (same as $user.* in filters) */
  user: UserSession

  /** Drizzle query builder — run any query against your database */
  db: DrizzleInstance

  /** Target table, e.g. 'main.orders' */
  table: string

  /** Detected operation */
  operation: 'select' | 'insert' | 'update' | 'delete'

  /** Columns the client is requesting or writing */
  columns: string[]

  /** Request body values (insert and update only) */
  input?: Record<string, any>

  /** Current resolved filter (after filter merging and $user.* substitution) */
  filter?: Record<string, any>
}
```

The `afterExecute` hook also receives the query results:

```typescript
interface AfterHookContext extends HookContext {
  /** Rows returned by the query */
  rows: any[]
}
```

## beforeExecute

Runs before the query hits the database. Use it to:

- **Deny requests** — throw to return 403
- **Modify filters** — return a new filter to extend the WHERE clause
- **Modify input** — return transformed input data for writes
- **Run side-effect queries** — look up related data via `ctx.db`

### Return Values

| Return | Effect |
|---|---|
| `void` (return nothing) | Query proceeds unchanged |
| `{ filter: {...} }` | Merges with existing filter (AND) |
| `{ input: {...} }` | Merges with existing input data |
| `{ columns: [...] }` | Overrides the column list |
| `throw` | Request is rejected with 403 |

```typescript
interface HookResult {
  filter?: Record<string, any>
  input?: Record<string, any>
  columns?: string[]
}
```

### Examples

#### Validate Against External Data

Check a related table before allowing the query:

```typescript
hooks: {
  beforeExecute: async ({ user, db, operation }) => {
    if (operation === 'insert') {
      const org = await db.query.organizations.findFirst({
        where: eq(organizations.id, user.current_org_id),
      })
      if (org.order_count >= org.order_limit) {
        throw new PermissionError('Organization order limit reached')
      }
    }
  },
}
```

#### Dynamic Filter Based on Lookup

Add filters based on data only known at runtime:

```typescript
hooks: {
  beforeExecute: async ({ user, db }) => {
    const teamIds = await db
      .select({ id: teams.id })
      .from(teams)
      .innerJoin(teamMembers, eq(teamMembers.teamId, teams.id))
      .where(
        and(
          eq(teamMembers.userId, user.id),
          eq(teamMembers.status, 'active'),
          gte(teamMembers.joinedAt, subDays(new Date(), 90)),
        ),
      )

    return {
      filter: { team_id: { $in: teamIds.map(t => t.id) } },
    }
  },
}
```

#### Transform Input on Write

Normalize or enrich data before it's written:

```typescript
hooks: {
  beforeExecute: async ({ input, operation }) => {
    if (operation === 'insert' && input) {
      return {
        input: {
          ...input,
          email: input.email?.toLowerCase().trim(),
          slug: input.name?.toLowerCase().replace(/\s+/g, '-'),
        },
      }
    }
  },
}
```

#### Restrict Columns by Plan

Dynamically limit visible columns based on the user's subscription:

```typescript
hooks: {
  beforeExecute: async ({ user, db }) => {
    const plan = await db.query.subscriptions.findFirst({
      where: eq(subscriptions.userId, user.id),
      columns: { plan: true },
    })
    if (plan?.plan === 'free') {
      return {
        columns: ['id', 'name', 'status', 'created_at'],
      }
    }
    // Paid users see all columns (no override)
  },
}
```

## afterExecute

Runs after the query returns results. Use it to:

- **Transform rows** — redact fields, compute virtual columns
- **Filter results** — remove rows based on logic that can't be expressed in SQL
- **Side effects** — trigger notifications, update counters, write audit entries

### Return Values

| Return | Effect |
|---|---|
| `void` (return nothing) | Results pass through unchanged |
| `any[]` | Replaces the result set |

### Examples

#### Redact Sensitive Fields

Mask data based on the user's role:

```typescript
hooks: {
  afterExecute: async ({ user, rows }) => {
    if (!user.roles.includes('admin')) {
      return rows.map(row => ({
        ...row,
        email: row.email ? `${row.email[0]}***@***` : null,
        phone: row.phone ? '***-****' : null,
      }))
    }
  },
}
```

#### Add Computed Fields

Attach data that isn't stored in the table:

```typescript
hooks: {
  afterExecute: async ({ db, rows }) => {
    if (rows.length === 0) return

    const orderIds = rows.map(r => r.id)
    const counts = await db
      .select({
        orderId: orderItems.orderId,
        itemCount: count(),
      })
      .from(orderItems)
      .where(inArray(orderItems.orderId, orderIds))
      .groupBy(orderItems.orderId)

    const countMap = new Map(counts.map(c => [c.orderId, c.itemCount]))
    return rows.map(row => ({
      ...row,
      item_count: countMap.get(row.id) ?? 0,
    }))
  },
}
```

#### Log High-Value Operations

Write custom audit entries for sensitive queries:

```typescript
hooks: {
  afterExecute: async ({ user, db, table, operation, rows }) => {
    if (operation === 'select' && rows.length > 1000) {
      await db.insert(auditLogs).values({
        userId: user.id,
        action: 'large_export',
        table,
        rowCount: rows.length,
        timestamp: new Date(),
      })
    }
  },
}
```

## Combining Hooks with Declarative Rules

Hooks work alongside filters, checks, presets, and custom SQL. The engine applies them in order:

```text
1. filter      → WHERE clause injected
2. check       → Input values validated
3. preset      → Server values injected
4. customSql   → SQL fragment appended to WHERE
5. hooks.beforeExecute → Your TypeScript runs
6. Query executes
7. hooks.afterExecute  → Your TypeScript runs on results
```

This means you can use declarative rules for the common cases and hooks for the edge cases:

```typescript
manage_orders: {
  name: 'Manage orders',
  table: 'main.orders',
  operations: { select: true, insert: true, update: true },
  // Declarative: org scoping
  filter: { organization_id: { $in: '$user.org_ids' } },
  // Declarative: value validation
  check: { amount: { $gte: 0 } },
  // Declarative: audit columns
  preset: { updated_by: '$user.id' },
  // Programmatic: business logic that can't be expressed declaratively
  hooks: {
    beforeExecute: async ({ user, db, operation, input }) => {
      if (operation === 'update' && input?.status === 'approved') {
        const approverRole = await db.query.orgMembers.findFirst({
          where: and(
            eq(orgMembers.userId, user.id),
            eq(orgMembers.orgId, user.current_org_id),
          ),
          columns: { role: true },
        })
        if (approverRole?.role !== 'manager') {
          throw new PermissionError('Only managers can approve orders')
        }
      }
    },
  },
}
```

## Error Handling

Throw `PermissionError` to reject with `403 Forbidden`:

```typescript
hooks: {
  beforeExecute: async (ctx) => {
    throw new PermissionError('Reason shown in error response')
  },
}
```

Any other thrown error returns `500 Internal Server Error` and is logged but not exposed to the client.

## When to Use Hooks

| Use Case | Recommendation |
|---|---|
| Static row filtering | Use [filters](/docs/backend/permissions/filters) |
| Value validation | Use [checks](/docs/backend/permissions/checks) |
| Auto-set columns | Use [presets](/docs/backend/permissions/presets) |
| Date math, computed WHERE | Use [custom SQL](/docs/backend/permissions/custom-sql) |
| Lookup-based access control | Use `beforeExecute` hook |
| Business rule validation | Use `beforeExecute` hook |
| Input transformation | Use `beforeExecute` hook |
| Result transformation | Use `afterExecute` hook |
| Side effects (audit, notifications) | Use `afterExecute` hook |

Prefer declarative rules when possible. Use hooks only when the built-in mechanisms cannot express your logic.
