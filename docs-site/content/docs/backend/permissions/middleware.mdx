---
title: Middleware
icon: Code
description: Run custom TypeScript that wraps query execution, with full access to the database, user session, and query data.
---

When declarative filters, checks, and presets are not enough, `middleware` lets you wrap the query execution with custom TypeScript. Every parameter is destructured — you work directly with `user`, `db`, `filter`, `input`, and pass overrides to `next()` to modify what gets executed.

```typescript
permissions: {
  create_order: {
    name: 'Create order',
    table: 'main.orders',
    operations: { insert: true },
    columns: ['product_id', 'quantity'],
    middleware: async ({ user, db, operation, input }, next) => {
      // Look up the product to validate stock
      const product = await db.query.products.findFirst({
        where: eq(products.id, input.product_id),
      })
      if (!product || product.stock < input.quantity) {
        throw new PermissionError('Insufficient stock')
      }

      // Execute the insert inside a transaction so we can
      // decrement stock atomically — if anything fails, both
      // the insert and the stock update roll back
      return db.transaction(async (tx) => {
        const rows = await next({ db: tx })

        await tx
          .update(products)
          .set({ stock: product.stock - input.quantity })
          .where(eq(products.id, input.product_id))

        return rows
      })
    },
  },
}
```

## How It Works

The middleware function receives destructured query context and a `next()` function. Call `next()` to execute the query — pass overrides to modify what gets executed:

```typescript
middleware: async ({ user, db, table, operation, columns, query, input, filter }, next) => {
  // 1. Before query — validate, compute new values
  const rows = await next({ filter: { ...filter, status: { $ne: 'archived' } } })
  // 2. After query — transform rows, run side effects
  return rows
}
```

- **Before `next()`** — validate access, look up data, compute overrides
- **`next(overrides)`** — executes the query with any overrides applied
- **After `next()`** — transform results, run side effects
- **Skip `next()`** — throw to deny the request entirely

```text
  6. Permission Check — filters, checks, presets applied
    │
    ▼
  6a. middleware (before next) ← your code runs here
    │
    ▼
  7. DuckDB Execution ← next() triggers this
    │
    ▼
  7a. middleware (after next) ← your code runs here
    │
    ▼
  8. Audit Log
```

## Parameters

Every parameter is destructured — no wrapper object:

```typescript
middleware: async ({ user, db, table, operation, columns, query, input, filter }, next) => {
```

| Parameter | Type | Description |
|---|---|---|
| `user` | `UserSession` | Resolved session (same as `$user.*` in filters) |
| `db` | `DrizzleInstance` | Drizzle query builder — run any query |
| `table` | `string` | Target table, e.g. `'main.orders'` |
| `operation` | `'select' \| 'insert' \| 'update' \| 'delete'` | Detected operation |
| `columns` | `string[]` | Columns the client is requesting or writing |
| `query` | `{ sql: string, params: any[] }` | The client's raw parameterized SQL |
| `input` | `Record<string, any> \| undefined` | Request body values (writes only) |
| `filter` | `Record<string, any> \| undefined` | Resolved filter (after merging and `$user.*` substitution) |

## Passing Overrides to next()

Pass an object to `next()` to override any parameter before execution:

```typescript
middleware: async ({ filter, columns, input }, next) => {
  return next({
    // Extend the filter
    filter: { ...filter, status: { $ne: 'archived' } },
    // Restrict columns
    columns: ['id', 'name', 'status'],
    // Normalize input
    input: { ...input, email: input?.email?.toLowerCase().trim() },
  })
},
```

| Override | Effect |
|---|---|
| `filter` | Replaces the filter used in the WHERE clause |
| `input` | Replaces the input data for writes |
| `columns` | Replaces the column list |
| `db` | Replaces the database instance (use for transactions) |

If you call `next()` with no arguments, the query executes unchanged.

## Transactions

Wrap `next()` in `db.transaction()` and pass the transaction as `db` — if anything throws after the query, everything rolls back:

```typescript
middleware: async ({ user, db, input }, next) => {
  return db.transaction(async (tx) => {
    // The main query runs inside the transaction
    const rows = await next({ db: tx })

    // This runs after the query — if it throws, both the
    // main query and this update are rolled back
    await tx.insert(auditLogs).values({
      userId: user.id,
      action: 'order_created',
      orderId: rows[0]?.id,
      timestamp: new Date(),
    })

    return rows
  })
},
```

This is especially useful for writes that need atomic side effects — stock decrements, balance updates, counter increments, or any operation where partial completion is not acceptable.

## Examples

### Real-World: Order Creation with Stock Validation

A complete example combining pre-validation, transactions, and post-query side effects:

```typescript
create_order: {
  name: 'Create order',
  table: 'main.orders',
  operations: { insert: true },
  columns: ['product_id', 'quantity', 'shipping_address'],
  preset: {
    customer_id: '$user.id',
    organization_id: '$user.current_org_id',
    status: 'pending',
  },
  check: {
    quantity: { $gte: 1, $lte: 100 },
  },
  middleware: async ({ user, db, input }, next) => {
    // 1. Validate: check product exists and has stock
    const product = await db.query.products.findFirst({
      where: and(
        eq(products.id, input.product_id),
        eq(products.organizationId, user.current_org_id),
      ),
    })
    if (!product) {
      throw new PermissionError('Product not found')
    }
    if (product.stock < input.quantity) {
      throw new PermissionError(
        `Only ${product.stock} units available`,
      )
    }

    // 2. Execute atomically: insert order + decrement stock
    return db.transaction(async (tx) => {
      const rows = await next({
        db: tx,
        input: {
          ...input,
          unit_price: product.price,
          total: product.price * input.quantity,
        },
      })

      await tx
        .update(products)
        .set({ stock: sql`stock - ${input.quantity}` })
        .where(eq(products.id, input.product_id))

      // 3. Side effect: notify warehouse (if this fails, order rolls back)
      await tx.insert(warehouseJobs).values({
        orderId: rows[0].id,
        productId: input.product_id,
        quantity: input.quantity,
        status: 'queued',
      })

      return rows
    })
  },
}
```

This permission:
1. Uses **declarative** `preset`, `check`, and `columns` for the simple stuff
2. Uses **middleware** to validate stock, compute the price, atomically decrement inventory, and queue a warehouse job — all in one transaction

### Dynamic Filter Based on Lookup

Add filters based on data only known at runtime:

```typescript
middleware: async ({ user, db, filter }, next) => {
  const teamIds = await db
    .select({ id: teams.id })
    .from(teams)
    .innerJoin(teamMembers, eq(teamMembers.teamId, teams.id))
    .where(
      and(
        eq(teamMembers.userId, user.id),
        eq(teamMembers.status, 'active'),
      ),
    )

  return next({
    filter: { ...filter, team_id: { $in: teamIds.map(t => t.id) } },
  })
},
```

### Restrict Columns by Plan

Dynamically limit visible columns based on the user's subscription:

```typescript
middleware: async ({ user, db }, next) => {
  const sub = await db.query.subscriptions.findFirst({
    where: eq(subscriptions.userId, user.id),
    columns: { plan: true },
  })
  if (sub?.plan === 'free') {
    return next({ columns: ['id', 'name', 'status', 'created_at'] })
  }
  return next()
},
```

### Redact Sensitive Fields

Mask data based on the user's role:

```typescript
middleware: async ({ user }, next) => {
  const rows = await next()

  if (!user.roles.includes('admin')) {
    return rows.map(row => ({
      ...row,
      email: row.email ? `${row.email[0]}***@***` : null,
      phone: row.phone ? '***-****' : null,
    }))
  }
  return rows
},
```

### Add Computed Fields

Attach data that isn't stored in the table:

```typescript
middleware: async ({ db }, next) => {
  const rows = await next()
  if (rows.length === 0) return rows

  const orderIds = rows.map(r => r.id)
  const counts = await db
    .select({
      orderId: orderItems.orderId,
      itemCount: count(),
    })
    .from(orderItems)
    .where(inArray(orderItems.orderId, orderIds))
    .groupBy(orderItems.orderId)

  const countMap = new Map(counts.map(c => [c.orderId, c.itemCount]))
  return rows.map(row => ({
    ...row,
    item_count: countMap.get(row.id) ?? 0,
  }))
},
```

### Transactional Write with Rollback

Ensure a write and its side effects succeed or fail together:

```typescript
middleware: async ({ user, db, operation }, next) => {
  if (operation !== 'delete') return next()

  return db.transaction(async (tx) => {
    const rows = await next({ db: tx })

    // Recalculate org usage — if this fails, the delete rolls back
    const remaining = await tx
      .select({ count: count() })
      .from(orders)
      .where(eq(orders.organizationId, user.current_org_id))

    await tx
      .update(organizations)
      .set({ orderCount: remaining[0].count })
      .where(eq(organizations.id, user.current_org_id))

    return rows
  })
},
```

## Combining with Declarative Rules

Middleware works alongside filters, checks, presets, and custom SQL. The engine applies them in order:

```text
1. filter      → WHERE clause injected
2. check       → Input values validated
3. preset      → Server values injected
4. customSql   → SQL fragment appended to WHERE
5. middleware   → Your TypeScript wraps the execution
6. Query executes (inside next())
```

Use declarative rules for the common cases and middleware for the edge cases:

```typescript
manage_orders: {
  name: 'Manage orders',
  table: 'main.orders',
  operations: { select: true, insert: true, update: true },
  filter: { organization_id: { $in: '$user.org_ids' } },
  check: { amount: { $gte: 0 } },
  preset: { updated_by: '$user.id' },
  middleware: async ({ user, db, operation, input }, next) => {
    if (operation === 'update' && input?.status === 'approved') {
      const membership = await db.query.orgMembers.findFirst({
        where: and(
          eq(orgMembers.userId, user.id),
          eq(orgMembers.orgId, user.current_org_id),
        ),
        columns: { role: true },
      })
      if (membership?.role !== 'manager') {
        throw new PermissionError('Only managers can approve orders')
      }
    }

    const rows = await next()

    if (!user.roles.includes('manager')) {
      return rows.map(({ internal_notes, ...row }) => row)
    }
    return rows
  },
}
```

## Error Handling

Throw `PermissionError` to reject with `403 Forbidden`:

```typescript
middleware: async (params, next) => {
  throw new PermissionError('Reason shown in error response')
},
```

Any other thrown error returns `500 Internal Server Error` and is logged but not exposed to the client. When using transactions, any throw inside `db.transaction()` automatically rolls back all queries within that transaction.

## When to Use

| Use Case | Recommendation |
|---|---|
| Static row filtering | Use [filters](/docs/backend/permissions/filters) |
| Value validation | Use [checks](/docs/backend/permissions/checks) |
| Auto-set columns | Use [presets](/docs/backend/permissions/presets) |
| Date math, computed WHERE | Use [custom SQL](/docs/backend/permissions/custom-sql) |
| Lookup-based access control | Use `middleware` |
| Business rule validation | Use `middleware` |
| Input transformation | Use `middleware` |
| Result transformation | Use `middleware` |
| Atomic writes with side effects | Use `middleware` with `db.transaction()` |

Prefer declarative rules when possible. Use `middleware` only when the built-in mechanisms cannot express your logic.
