---
title: Middleware
icon: Code
description: Run custom TypeScript that wraps query execution, with full access to the database, user session, and query data.
---

When declarative filters, checks, and presets are not enough, `middleware` lets you wrap the query execution with custom TypeScript. You get full access to the database, the user session, and the client's query — and you control when (or if) the query runs.

```typescript
permissions: {
  view_orders: {
    name: 'View orders',
    table: 'main.orders',
    operations: { select: true },
    columns: '*',
    middleware: async (ctx, next) => {
      const subscription = await ctx.db.query.subscriptions.findFirst({
        where: eq(subscriptions.userId, ctx.user.id),
      })
      if (subscription?.status !== 'active') {
        throw new PermissionError('Active subscription required')
      }
      return next()
    },
  },
}
```

## How It Works

The middleware function wraps the query execution. Call `next()` to execute the query and get the results back:

```typescript
middleware: async (ctx, next) => {
  // 1. Before query — validate, modify ctx.filter / ctx.input / ctx.columns
  const rows = await next()
  // 2. After query — transform rows, run side effects
  return rows
}
```

- **Before `next()`** — runs after permission checks (step 6) but before DuckDB execution (step 7)
- **After `next()`** — runs after execution but before the response (step 9)
- **Skip `next()`** — throw to deny the request entirely

```text
  6. Permission Check — filters, checks, presets applied
    │
    ▼
  6a. middleware (before next) ← your code runs here
    │
    ▼
  7. DuckDB Execution ← next() triggers this
    │
    ▼
  7a. middleware (after next) ← your code runs here
    │
    ▼
  8. Audit Log
```

## Query Context

The `ctx` object contains everything you need:

```typescript
interface QueryContext {
  /** Resolved user session (same as $user.* in filters) */
  user: UserSession

  /** Drizzle query builder — run any query against your database */
  db: DrizzleInstance

  /** Target table, e.g. 'main.orders' */
  table: string

  /** Detected operation */
  operation: 'select' | 'insert' | 'update' | 'delete'

  /** Columns the client is requesting or writing */
  columns: string[]

  /** The client's raw query */
  query: {
    /** Parameterized SQL sent by Drizzle Proxy */
    sql: string
    /** Parameter values */
    params: any[]
  }

  /** Request body values (insert and update only) */
  input?: Record<string, any>

  /** Current resolved filter (after filter merging and $user.* substitution) */
  filter?: Record<string, any>
}
```

### Modifying the Query

Mutate `ctx` properties before calling `next()` to change what gets executed:

```typescript
middleware: async (ctx, next) => {
  // Add an extra filter condition
  ctx.filter = {
    ...ctx.filter,
    status: { $ne: 'archived' },
  }

  // Restrict columns
  ctx.columns = ['id', 'name', 'status']

  // Normalize input before write
  if (ctx.input?.email) {
    ctx.input.email = ctx.input.email.toLowerCase().trim()
  }

  return next()
},
```

## Examples

### Validate Against External Data

Check a related table before allowing the query:

```typescript
middleware: async (ctx, next) => {
  if (ctx.operation === 'insert') {
    const org = await ctx.db.query.organizations.findFirst({
      where: eq(organizations.id, ctx.user.current_org_id),
    })
    if (org.order_count >= org.order_limit) {
      throw new PermissionError('Organization order limit reached')
    }
  }
  return next()
},
```

### Dynamic Filter Based on Lookup

Add filters based on data only known at runtime:

```typescript
middleware: async (ctx, next) => {
  const teamIds = await ctx.db
    .select({ id: teams.id })
    .from(teams)
    .innerJoin(teamMembers, eq(teamMembers.teamId, teams.id))
    .where(
      and(
        eq(teamMembers.userId, ctx.user.id),
        eq(teamMembers.status, 'active'),
        gte(teamMembers.joinedAt, subDays(new Date(), 90)),
      ),
    )

  ctx.filter = {
    ...ctx.filter,
    team_id: { $in: teamIds.map(t => t.id) },
  }

  return next()
},
```

### Restrict Columns by Plan

Dynamically limit visible columns based on the user's subscription:

```typescript
middleware: async (ctx, next) => {
  const sub = await ctx.db.query.subscriptions.findFirst({
    where: eq(subscriptions.userId, ctx.user.id),
    columns: { plan: true },
  })
  if (sub?.plan === 'free') {
    ctx.columns = ['id', 'name', 'status', 'created_at']
  }
  return next()
},
```

### Normalize Input on Write

Clean up data before it hits the database:

```typescript
middleware: async (ctx, next) => {
  if (ctx.operation === 'insert' && ctx.input) {
    ctx.input.email = ctx.input.email?.toLowerCase().trim()
    ctx.input.slug = ctx.input.name?.toLowerCase().replace(/\s+/g, '-')
  }
  return next()
},
```

### Redact Sensitive Fields

Mask data based on the user's role:

```typescript
middleware: async (ctx, next) => {
  const rows = await next()

  if (!ctx.user.roles.includes('admin')) {
    return rows.map(row => ({
      ...row,
      email: row.email ? `${row.email[0]}***@***` : null,
      phone: row.phone ? '***-****' : null,
    }))
  }
  return rows
},
```

### Add Computed Fields

Attach data that isn't stored in the table:

```typescript
middleware: async (ctx, next) => {
  const rows = await next()
  if (rows.length === 0) return rows

  const orderIds = rows.map(r => r.id)
  const counts = await ctx.db
    .select({
      orderId: orderItems.orderId,
      itemCount: count(),
    })
    .from(orderItems)
    .where(inArray(orderItems.orderId, orderIds))
    .groupBy(orderItems.orderId)

  const countMap = new Map(counts.map(c => [c.orderId, c.itemCount]))
  return rows.map(row => ({
    ...row,
    item_count: countMap.get(row.id) ?? 0,
  }))
},
```

### Log High-Value Operations

Write custom audit entries for sensitive queries:

```typescript
middleware: async (ctx, next) => {
  const rows = await next()

  if (ctx.operation === 'select' && rows.length > 1000) {
    await ctx.db.insert(auditLogs).values({
      userId: ctx.user.id,
      action: 'large_export',
      table: ctx.table,
      rowCount: rows.length,
      timestamp: new Date(),
    })
  }
  return rows
},
```

### Inspect the Client Query

Use `ctx.query` to make decisions based on the raw SQL:

```typescript
middleware: async (ctx, next) => {
  if (!ctx.query.sql.includes('created_at')) {
    throw new PermissionError('Query must include a created_at filter')
  }
  return next()
},
```

## Combining with Declarative Rules

Middleware works alongside filters, checks, presets, and custom SQL. The engine applies them in order:

```text
1. filter      → WHERE clause injected
2. check       → Input values validated
3. preset      → Server values injected
4. customSql   → SQL fragment appended to WHERE
5. middleware   → Your TypeScript wraps the execution
6. Query executes (inside next())
```

Use declarative rules for the common cases and middleware for the edge cases:

```typescript
manage_orders: {
  name: 'Manage orders',
  table: 'main.orders',
  operations: { select: true, insert: true, update: true },
  // Declarative: org scoping
  filter: { organization_id: { $in: '$user.org_ids' } },
  // Declarative: value validation
  check: { amount: { $gte: 0 } },
  // Declarative: audit columns
  preset: { updated_by: '$user.id' },
  // Programmatic: business logic
  middleware: async (ctx, next) => {
    // Before: only managers can approve
    if (ctx.operation === 'update' && ctx.input?.status === 'approved') {
      const membership = await ctx.db.query.orgMembers.findFirst({
        where: and(
          eq(orgMembers.userId, ctx.user.id),
          eq(orgMembers.orgId, ctx.user.current_org_id),
        ),
        columns: { role: true },
      })
      if (membership?.role !== 'manager') {
        throw new PermissionError('Only managers can approve orders')
      }
    }

    const rows = await next()

    // After: strip internal_notes for non-managers
    if (!ctx.user.roles.includes('manager')) {
      return rows.map(({ internal_notes, ...row }) => row)
    }
    return rows
  },
}
```

## Error Handling

Throw `PermissionError` to reject with `403 Forbidden`:

```typescript
middleware: async (ctx, next) => {
  throw new PermissionError('Reason shown in error response')
},
```

Any other thrown error returns `500 Internal Server Error` and is logged but not exposed to the client.

## When to Use

| Use Case | Recommendation |
|---|---|
| Static row filtering | Use [filters](/docs/backend/permissions/filters) |
| Value validation | Use [checks](/docs/backend/permissions/checks) |
| Auto-set columns | Use [presets](/docs/backend/permissions/presets) |
| Date math, computed WHERE | Use [custom SQL](/docs/backend/permissions/custom-sql) |
| Lookup-based access control | Use `middleware` |
| Business rule validation | Use `middleware` |
| Input transformation | Use `middleware` |
| Result transformation | Use `middleware` |
| Side effects (audit, notifications) | Use `middleware` |

Prefer declarative rules when possible. Use `middleware` only when the built-in mechanisms cannot express your logic.
