---
title: Query Methods
description: "All available query methods with type signatures."
---

Every table accessor on the client exposes seven query methods. All methods return promises and send structured JSON to the server's `/data` endpoint.

```typescript
const db = createClient<SuperAppSchema>({ url, userToken })

// Access pattern: db.{connection}.{table}.{method}(options)
db.main.orders.findMany({ ... })
db.main.orders.findOne({ ... })
db.main.orders.create({ ... })
db.main.orders.update({ ... })
db.main.orders.delete({ ... })
db.main.orders.count({ ... })
db.main.orders.aggregate({ ... })
```

## Method Reference

### `findMany`

Retrieve multiple rows with optional filtering, sorting, and pagination.

```typescript
findMany(options?: FindManyOptions): Promise<Row[]>
```

| Option | Type | Required | Description |
|---|---|---|---|
| `select` | `string[]` | No | Columns to return. Omit to return all permitted columns. |
| `where` | `FilterObject` | No | Filter conditions. See [Filter Operators](/docs/api-reference/client/filter-operators). |
| `include` | `IncludeObject` | No | Related tables to include (join). |
| `orderBy` | `Record<string, 'asc' \| 'desc'>` | No | Sort order. Multiple keys are applied in order. |
| `limit` | `number` | No | Maximum number of rows to return. |
| `offset` | `number` | No | Number of rows to skip (for pagination). |

```typescript
const orders = await db.main.orders.findMany({
  select: ['id', 'amount', 'status', 'created_at'],
  where: {
    status: { $eq: 'active' },
    amount: { $gte: 100 },
  },
  include: {
    customer: {
      select: ['id', 'name', 'email'],
    },
  },
  orderBy: { created_at: 'desc' },
  limit: 50,
  offset: 0,
})
// Return type: {
//   id: string; amount: number; status: string; created_at: string;
//   customer: { id: string; name: string; email: string }
// }[]
```

### `findOne`

Retrieve a single row matching a condition. Returns `null` if no row matches.

```typescript
findOne(options: FindOneOptions): Promise<Row | null>
```

| Option | Type | Required | Description |
|---|---|---|---|
| `where` | `FilterObject` | Yes | Filter conditions to match a single row. |
| `select` | `string[]` | No | Columns to return. Omit to return all permitted columns. |
| `include` | `IncludeObject` | No | Related tables to include. |

```typescript
const order = await db.main.orders.findOne({
  where: { id: { $eq: 'ord_abc123' } },
  select: ['id', 'amount', 'status'],
  include: {
    customer: {
      select: ['id', 'name'],
    },
  },
})
// Return type: {
//   id: string; amount: number; status: string;
//   customer: { id: string; name: string }
// } | null

if (!order) {
  console.log('Not found')
  return
}
```

### `create`

Insert a new row and return the created record.

```typescript
create(options: CreateOptions): Promise<Row>
```

| Option | Type | Required | Description |
|---|---|---|---|
| `data` | `Record<string, any>` | Yes | The row data to insert. Only columns allowed by the permission are accepted. |
| `select` | `string[]` | No | Columns to return in the created record. |

```typescript
const newOrder = await db.main.orders.create({
  data: {
    amount: 250,
    status: 'draft',
    notes: 'New order from API',
  },
  select: ['id', 'amount', 'status', 'created_at'],
})
// Return type: { id: string; amount: number; status: string; created_at: string }
```

Server-side presets (like `created_by`, `organization_id`) are injected automatically by the permission engine. Any client-provided values for preset columns are overridden.

### `update`

Update rows matching a condition and return the updated records.

```typescript
update(options: UpdateOptions): Promise<Row[]>
```

| Option | Type | Required | Description |
|---|---|---|---|
| `where` | `FilterObject` | Yes | Filter conditions to select rows to update. Permission filters are applied on top. |
| `data` | `Record<string, any>` | Yes | The new values to set. Only columns allowed by the permission are accepted. |
| `select` | `string[]` | No | Columns to return in the updated records. |

```typescript
const updated = await db.main.orders.update({
  where: { id: { $eq: 'ord_abc123' } },
  data: {
    status: 'active',
    notes: 'Approved by manager',
  },
  select: ['id', 'status', 'updated_at'],
})
// Return type: { id: string; status: string; updated_at: string }[]
```

The permission filter is always applied. If the user does not have permission to update the matched rows, zero rows are updated and an empty array is returned.

### `delete`

Delete rows matching a condition and return the count of deleted rows.

```typescript
delete(options: DeleteOptions): Promise<{ count: number }>
```

| Option | Type | Required | Description |
|---|---|---|---|
| `where` | `FilterObject` | Yes | Filter conditions to select rows to delete. Permission filters are applied on top. |

```typescript
const result = await db.main.orders.delete({
  where: { id: { $eq: 'ord_abc123' } },
})
// Return type: { count: number }
// result.count === 1 if the row existed and was permitted
// result.count === 0 if the row didn't exist or wasn't permitted
```

### `count`

Count rows matching an optional condition.

```typescript
count(options?: CountOptions): Promise<number>
```

| Option | Type | Required | Description |
|---|---|---|---|
| `where` | `FilterObject` | No | Filter conditions. If omitted, counts all permitted rows. |

```typescript
const total = await db.main.orders.count()
// Return type: number

const activeCount = await db.main.orders.count({
  where: { status: { $eq: 'active' } },
})
// Return type: number
```

Permission filters are always applied. The count reflects only rows the user is permitted to see.

### `aggregate`

Perform aggregate calculations on columns.

```typescript
aggregate(options: AggregateOptions): Promise<AggregateResult>
```

| Option | Type | Required | Description |
|---|---|---|---|
| `where` | `FilterObject` | No | Filter conditions applied before aggregation. |
| `operations` | `AggregateOperation[]` | Yes | Array of aggregate operations to perform. |
| `groupBy` | `string[]` | No | Columns to group by. |

Each aggregate operation has the shape:

| Field | Type | Required | Description |
|---|---|---|---|
| `fn` | `'sum' \| 'avg' \| 'min' \| 'max' \| 'count'` | Yes | Aggregate function. |
| `column` | `string` | Yes (except `count`) | Column to aggregate. For `count`, use `'*'`. |
| `alias` | `string` | No | Name for the result field. Defaults to `fn_column`. |

```typescript
const stats = await db.main.orders.aggregate({
  where: { status: { $eq: 'active' } },
  operations: [
    { fn: 'sum', column: 'amount', alias: 'total_amount' },
    { fn: 'avg', column: 'amount', alias: 'avg_amount' },
    { fn: 'count', column: '*', alias: 'order_count' },
    { fn: 'max', column: 'amount', alias: 'max_order' },
  ],
})
// Return type: {
//   total_amount: number;
//   avg_amount: number;
//   order_count: number;
//   max_order: number;
// }
```

With `groupBy`:

```typescript
const byStatus = await db.main.orders.aggregate({
  operations: [
    { fn: 'count', column: '*', alias: 'count' },
    { fn: 'sum', column: 'amount', alias: 'total' },
  ],
  groupBy: ['status'],
})
// Return type: {
//   status: string;
//   count: number;
//   total: number;
// }[]
```

## `include` (Relations)

The `include` option loads related data in a single request. The server resolves the join using the defined relationships.

```typescript
interface IncludeObject {
  [relationName: string]: {
    /** Columns to return from the related table */
    select?: string[]
    /** Filter the related rows */
    where?: FilterObject
    /** Sort the related rows */
    orderBy?: Record<string, 'asc' | 'desc'>
    /** Limit related rows */
    limit?: number
    /** Nested includes (up to maxIncludeDepth) */
    include?: IncludeObject
  }
}
```

```typescript
const orders = await db.main.orders.findMany({
  select: ['id', 'amount'],
  include: {
    customer: {
      select: ['name', 'email'],
    },
    line_items: {
      select: ['product_name', 'quantity', 'unit_price'],
      orderBy: { quantity: 'desc' },
      limit: 10,
      include: {
        product: {
          select: ['id', 'sku', 'category'],
        },
      },
    },
  },
})
```

The user must have SELECT permission on all included tables. If a permission is missing for a related table, that include is silently omitted from the response.

## Error Handling

All methods throw on server errors. Catch errors to handle permission denials, validation failures, and network issues.

```typescript
try {
  const order = await db.main.orders.create({
    data: { amount: -100, status: 'invalid' },
  })
} catch (error) {
  // error.message: "You do not have permission to perform this action."
  // error.code: "PERMISSION_DENIED"
  // error.correlationId: "req_abc123"
}
```
