---
title: Simplifying the Design
description: "Making superapp so obvious that documentation becomes optional."
icon: Minimize
---

The goal is not "fewer config keys." The goal is: **a developer with zero context opens your repo, reads the code, and understands what it does in 30 seconds.** If they need to open a docs page, the API failed.

This page redesigns superapp around that standard.

## The Test

A junior developer who has never heard of superapp should be able to:

1. Read a server file and understand what it does — without comments.
2. Read a client file and know how to query data — without examples.
3. Add a new table with permissions — without searching the docs.
4. Ship to production — without a configuration guide.

If any of those require documentation, the API needs to change.

## The Entire Server

```typescript
import { superapp } from 'superapp'

superapp({
  db: process.env.DATABASE_URL,
  auth: process.env.AUTH_SECRET,
  tables: {
    orders: {
      read: { where: { customer_id: '$user.id' } },
      write: { where: { customer_id: '$user.id' } },
    },
  },
})
```

That's it. Five lines of actual config. A Postgres connection, auth with a secret, and one table with row-level security. The server starts on port 3001.

No `createEngine`. No `betterAuthProvider`. No `postgresProvider`. No `createHonoMiddleware`. No `Hono`. No `serve`. No `integrations`. No `connections`. No `roles`. No `operations`. No `filter`. No `columns`. No `mode`.

### Why this works without docs

Every key reads as English:

- `db` — the database. A URL string. Everyone knows what a database URL looks like.
- `auth` — authentication. A secret string. That's all you need to turn it on.
- `tables` — the tables you're exposing. Named after your actual database tables.
- `read` / `write` — what users can do. Not `operations: { select: true }`. Not `allow: ['select']`. Just `read` and `write`.
- `where` — a SQL WHERE clause. Every developer already knows this word.
- `'$user.id'` — the current user's ID. The `$` prefix is a universal "this is a variable" signal.

A developer reading this code for the first time will understand it. Not after reading the docs. Not after a tutorial. Immediately.

## The Entire Client

```typescript
import { superapp } from 'superapp/client'

const app = superapp('http://localhost:3001')
```

One line. The client handles auth, session tokens, and database queries through a single object.

### Querying

```typescript
// Read
const orders = await app.orders.find({ status: 'active' })

// Read one
const order = await app.orders.findOne({ id: 'ord_123' })

// Create
const newOrder = await app.orders.create({ amount: 49.99, status: 'draft' })

// Update
await app.orders.update({ id: 'ord_123' }, { status: 'shipped' })

// Delete
await app.orders.delete({ id: 'ord_123' })
```

No Drizzle. No `db.select().from(schema.orders).where(eq(...))`. No schema import. No `drizzle-orm` filter functions.

The table names come from the server config. TypeScript autocomplete fills in the rest — `app.` shows you every table, `.find({` shows you every column.

**Why no Drizzle on the client?** Drizzle is excellent on the server. On the client, it's overhead. The developer has to import schema files, learn filter functions (`eq`, `gt`, `like`, `desc`), understand Drizzle Proxy, and manage a separate ORM instance. The object syntax above does the same thing with knowledge developers already have: `{ status: 'active' }` is a filter. Everyone knows that from MongoDB, Prisma, Supabase, and every REST API they've ever used.

The server still uses Drizzle Proxy + DuckDB internally — the client just speaks a simpler language.

### Auth

```typescript
// React
function App() {
  return (
    <app.AuthProvider>
      <Dashboard />
    </app.AuthProvider>
  )
}

// Sign in / sign up — drop-in component, zero config
function LoginPage() {
  return <app.AuthCard />
}

// Access the session anywhere
function NavBar() {
  const { user } = app.useSession()
  return <span>{user?.email}</span>
}
```

Auth components live on the same `app` object. No separate auth client, no token wiring, no `useDb` hook. The `AuthProvider` handles session state. Every query automatically includes the token.

## How the Server Defaults Work

The five-line server works because of aggressive defaults:

| What | Default | Override |
|---|---|---|
| Port | `3001` | `superapp({ port: 8080 })` |
| Database type | Auto-detected from URL (`postgres://` → Postgres, `mysql://` → MySQL, `file:` → SQLite) | `superapp({ db: { url: '...', type: 'mysql' } })` |
| Auth provider | better-auth | `superapp({ auth: { jwt: { jwksUrl: '...' } } })` |
| Columns | All columns exposed | `read: { columns: ['id', 'amount', 'status'] }` |
| Read access | Denied unless declared | Add `read: true` for public, or `read: { where: ... }` for scoped |
| Write access | Denied unless declared | Add `write: true` for public, or `write: { where: ... }` for scoped |
| Rate limiting | 200 req/min per user | `superapp({ limits: { perUser: 500 } })` |
| Audit logging | On | `superapp({ audit: false })` |
| Admin UI | Off | `superapp({ admin: process.env.ADMIN_KEY })` |

**The key insight:** `read` and `write` are denied by default. This means the developer must explicitly declare every table they want to expose. You can't accidentally leak data. The secure path is the default path — and it requires zero configuration.

## Progressive Disclosure

The API has three layers. Most developers never leave layer 1.

### Layer 1: Just Works (90% of apps)

```typescript
superapp({
  db: process.env.DATABASE_URL,
  auth: process.env.AUTH_SECRET,
  tables: {
    orders: {
      read: { where: { customer_id: '$user.id' } },
      write: { where: { customer_id: '$user.id' } },
    },
    products: {
      read: true,  // anyone can read, no write access
    },
  },
})
```

### Layer 2: Roles and Validation (multi-role apps)

```typescript
superapp({
  db: process.env.DATABASE_URL,
  auth: process.env.AUTH_SECRET,
  tables: {
    orders: {
      read: [
        { role: 'user', where: { customer_id: '$user.id' } },
        { role: 'admin' },  // admins see everything
      ],
      write: [
        { role: 'user', where: { customer_id: '$user.id' }, validate: { amount: { $lte: 10000 } } },
        { role: 'admin' },
      ],
    },
  },
})
```

When `read` or `write` is an array, each entry is a role-specific rule. The engine picks the first matching rule for the current user's role. No separate `roles` or `permissions` objects.

### Layer 3: Full Control (complex business logic)

```typescript
superapp({
  db: process.env.DATABASE_URL,
  auth: process.env.AUTH_SECRET,
  tables: {
    orders: {
      read: async ({ user, db }) => {
        const orgs = await db.query('SELECT org_id FROM members WHERE user_id = $1', [user.id])
        return { where: { org_id: { $in: orgs.map(o => o.org_id) } } }
      },
      write: async ({ user }) => {
        if (user.role === 'admin') return true
        return {
          where: { customer_id: user.id },
          validate: { amount: { $lte: user.spendLimit } },
          defaults: { created_by: user.id, org_id: user.orgId },
        }
      },
    },
  },
})
```

When `read` or `write` is a function, it runs per-request and returns the same shape as the declarative config. This replaces `middleware`, `customSql`, `resolve`, and every other escape hatch with one concept: **a function that returns rules.**

## Multiple Databases

```typescript
superapp({
  db: {
    main: process.env.PG_URL,
    analytics: process.env.ANALYTICS_URL,
    legacy: './data/legacy.sqlite',
  },
  auth: process.env.AUTH_SECRET,
  tables: {
    'main.orders': {
      read: { where: { customer_id: '$user.id' } },
    },
    'analytics.events': {
      read: { where: { org_id: '$user.org_id' } },
    },
    'legacy.customers': {
      read: true,
    },
  },
})
```

When `db` is an object, keys become database names. Table names become `database.table`. DuckDB handles cross-database joins automatically — that doesn't change.

## Mounting Into Existing Apps

Not everyone wants superapp to own the HTTP server. Mount it as middleware:

```typescript
import { superapp } from 'superapp'
import { Hono } from 'hono'

const engine = superapp({
  db: process.env.DATABASE_URL,
  auth: process.env.AUTH_SECRET,
  tables: { /* ... */ },
  serve: false,  // don't start a server
})

const app = new Hono()
app.route('/api', engine.handler)
```

When `serve: false`, the engine exports a standard `Request → Response` handler that works with Hono, Express, Next.js, or any framework.

## Type Safety Without Code Generation

The current design requires running `npx @superapp/backend generate` to get TypeScript types. This is a step that can break, go stale, or be forgotten.

**Proposed:** The client infers types from the server at build time.

```typescript
// server.ts — export the config for type inference
export const engine = superapp({
  db: process.env.DATABASE_URL,
  auth: process.env.AUTH_SECRET,
  tables: {
    orders: {
      read: { where: { customer_id: '$user.id' } },
      write: { where: { customer_id: '$user.id' } },
    },
  },
})

export type App = typeof engine
```

```typescript
// client.ts — import the type, get full autocomplete
import type { App } from '../server'
import { superapp } from 'superapp/client'

const app = superapp<App>('http://localhost:3001')

app.orders.find({ status: 'active' })
//   ^ autocomplete: orders
//                    ^ autocomplete: id, amount, status, customer_id, created_at
```

No codegen step. No generated files to keep in sync. The TypeScript compiler does the work. When you add a table to the server config, the client autocomplete updates on the next save.

For projects where the server and client are separate repos, the codegen CLI still works as a fallback:

```bash
npx superapp pull http://localhost:3001 --out ./types.ts
```

## Comparison to Alternatives

The simplified API should feel immediately familiar to developers coming from popular tools:

| Operation | superapp | Supabase | Prisma |
|---|---|---|---|
| Read | `app.orders.find({ status: 'active' })` | `supabase.from('orders').select().eq('status', 'active')` | `prisma.orders.findMany({ where: { status: 'active' } })` |
| Create | `app.orders.create({ amount: 50 })` | `supabase.from('orders').insert({ amount: 50 })` | `prisma.orders.create({ data: { amount: 50 } })` |
| Update | `app.orders.update({ id: '1' }, { status: 'shipped' })` | `supabase.from('orders').update({ status: 'shipped' }).eq('id', '1')` | `prisma.orders.update({ where: { id: '1' }, data: { status: 'shipped' } })` |
| Delete | `app.orders.delete({ id: '1' })` | `supabase.from('orders').delete().eq('id', '1')` | `prisma.orders.delete({ where: { id: '1' } })` |

**What superapp adds over all of these:** Row-level permissions are declared on the server and enforced automatically. The client never writes authorization logic.

## What Disappears

These concepts from the current design are removed entirely:

| Removed | Replaced by |
|---|---|
| `createEngine()` | `superapp()` — one function, one name |
| `@superapp/backend`, `@superapp/db`, `@superapp/auth` | `superapp` — one package |
| `integrations[]` | Auto-detected from URL |
| `connections{}` | `db` — a string or object |
| `betterAuthProvider()` | `auth` — a string (secret) or object |
| `operations: { select: true }` | `read` / `write` — two words |
| `filter`, `check`, `preset`, `customSql`, `middleware` | `where`, `validate`, `defaults`, or a function |
| `roles{}` | Inline `role` on each rule |
| `columns` (required) | All columns by default, restrict with `columns` when needed |
| Drizzle ORM on the client | `app.table.find()` / `.create()` / `.update()` / `.delete()` |
| `useDb()` hook + token wiring | Automatic — the client handles tokens internally |
| `createHonoMiddleware()` + manual server setup | `superapp()` starts the server; `serve: false` for manual mounting |
| `npx @superapp/backend generate` (required) | Type inference from server export; codegen as optional fallback |
| `mode: 'programmatic' \| 'admin_ui'` | Always programmatic; admin UI is an opt-in flag |

**14 concepts → 4:** `db`, `auth`, `tables`, `where`.

## Design Principles

These are the rules that govern every API decision:

1. **If it needs a docs page, it's too complex.** The API should be guessable. A developer who has used any database client should be able to use superapp by autocomplete alone.

2. **Strings over objects, objects over classes.** `db: 'postgres://...'` over `db: { type: 'postgres', url: '...' }` over `db: new PostgresProvider({ url: '...' })`. Use the simplest type that carries the information.

3. **One way to do each thing.** Not `filter` and `customSql` and `middleware`. One concept: `where` (an object) or a function that returns `where`. Two forms, one idea.

4. **Denied by default, explicit to allow.** Tables are invisible until you add them to `tables`. Columns are all visible by default (because hiding columns is the exception, not the rule). Write access is off until you add `write`. The safe path requires zero configuration.

5. **The server is the source of truth.** The client never defines permissions, roles, or access rules. It just calls `.find()`, `.create()`, `.update()`, `.delete()`, and the server decides what the user can see and do.

6. **Types travel with the code.** No codegen steps. Export a type from the server, import it on the client. TypeScript does the rest.

7. **Progressive disclosure, not progressive complexity.** Layer 1 (strings and objects) covers 90% of apps. Layer 2 (arrays with roles) covers 9%. Layer 3 (functions) covers 1%. A developer only encounters complexity when their problem is actually complex.
